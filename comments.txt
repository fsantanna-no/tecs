-------------------------------------------------------------------------------

> Referee: 1

> 1. The name of "static temporal analysis" may get confused with the existing
> work on static timing analysis (e.g., WCET or WCRT) on synchronous language,
> e.g., ''Performance Debugging of Esterel Specifications'' in RTS Journal, 2012
> [OK]
> Maybe it can be renamed as "static concurrency analysis".

%%%
To also address the comments of Referee 3, we renamed as "concurrency checks".
Please, see below for additional comments.
%%%

> 2. Furthermore, lexical order is used to schedule the concurrent statements in
> this work. What happens if there are data dependencies in the concurrent
> statements? Please discuss the proposed scheduling with the existing
> sequentialization techniques for Esterel compilation (e.g., a CFG-based
> compilation) [OK?].

%%%
The idea of data dependency is inherent to Esterel since it supports emitting
and testing the presence of a signal in the same cycle.
Due to the "coherence law", Esterel also requires that an <<emit>> must precede
a <<present>> test.
Therefore, CFG-based compilers create an acyclic graph respecting topological
order to satisfy these constraints.

Section 2.2 discusses internal events and describes that if an <<await>> and
<<emit>> occur simultaneously in parallel trails, the <<await>> does not awake.
Delayed awaits eliminate the idea of data dependency in Céu but are less
expressive. We discuss the tradeoffs in the paper.
In Section 3.3, we mention a field in the trail structure to deal with delayed
awaits in the implementation.

In this revision, we extended Sections 2.2 and 4 (related work) to clarify
this discussion.
%%%

> 3. The authors mentioned that "Unfortunately, most real applications in Esterel
> seems to be closed source". However, the Estbench (available at
> http://www1.cs.columbia.edu/~sedwards/software.html) [OK] can be used to
> perform the comparison and evaluation.

%%%
Maybe "widely-used applications" would be a more accurate term to use.
The TinyOS drivers and protocols (which we ported to Céu) are industrial-level
applications and serve as basis for a considerable amount of work in the
Wireless Sensor Network academic community (e.g., ACM SenSys, ACM IPSN,
IEEE DCOSS, and EWSN).
Although we avoid any quantitative comparisons with Esterel, the cited work [1]
is about a comprehensive evaluation in a constrained and distributed setting
showing a small overhead in resource usage in comparison to C.
We recognize that a quantitative analysis with Esterel is relevant, but C is
a standard benchmark language for evaluating embedded systems.
An Esterel implementation that compiles to sequential C code with similar
techniques "generates code less than 10% larger the original manually-sequenced
code" [4].
We have a student working on Esterel's "wristwatch" example [2] and plan to
extend our evaluation with industrial-quality applications in the future.

We rewrote the 2nd paragraph of Section 3 with the justification above and
moved this discussion to S.3.5 (Single-Threaded Dispatching)
TODO: see reviewer.3
%%%

-------------------------------------------------------------------------------

> Referee: 3

> The subsections on Single-Threaded Dispatching (§3.5) and
> the Terra Virtual Machine (§3.7) are uninformative.

%%%
TODO
%%%

> On the whole, I would have preferred a more neutral style (some parts of the
> paper read like a sales pitch)...
>
> ... a fairer evaluation of Esterel (there are good reasons for its design
> choices), ...
> ... The solutions embodied in Céu are well motivated but involve trade-offs
> that could be more thoroughly discussed in the paper.

%%%
We re-positioned Céu as targeting soft real-time systems only.
This changes the tone of the paper as less ambitious in comparison to Esterel
for a fairer evaluation.
We rewrote parts of the Abstract, S.1 (Introduction), S.3.5 (Single-Threaded
Dispatching), and S.5 (Conclusion), e.g.:

"The semantics of Céu implies an implementation with a runtime stack and a
sequential scheduler.
In contrast with Esterel's semantics, this prevents programs to be compiled
directly and efficiently to hardware [ref].
It also makes difficult to statically determine worst-case reaction times
for hard real-time systems [ref]."

"For soft real-time systems, accumulating delays and occasionally postponing
reactions might be enough.
However, hard real-time systems require a more robust approach such as
determining fixed-length ticks that can be statically verified."

"We present the design and implementation of Céu, a synchronous reactive 
language inspired by Esterel with event-driven semantics and more fine-grained 
control for intra-reaction execution.
On the one hand, this approach is familiar to programmers in general,
abstracting tick sampling with reactions to unique events from their
application domain.
On the other hand, this level of abstraction does not suit systems with
hard-real time requirements, in which interacting directly with a concrete
notion of tick is more robust."

We also proof-read the paper and removed/renamed many non-neutral terms:
"overly complex semantics", "drawback", "loose execution",
"has a simple semantics", "only possible", "seamless", "easily trackable",
"goes one step further", "unique"
%%%

> ... a more formal description of the language and its
> implementation (at the very least, a concise definition of the core abstract
> syntax -- I just noticed that the original submission included this
> definition in Figure 10; ...).

In S.2 (Figure 2), we present the subset of the concrete syntax of Céu used in
the paper as a quick reference.
We also mention about "the formal specification of the semantics of Céu with a
simplified abstract syntax in a separate paper [ref]".

* The queueing of external events and the stacking of internal ones
simplifies compilation and static analysis but complicates the formal
model and reasoning, which must account for a list of pending events, and
the relationship between reactions and real-time, as more complicated
assumptions are required on event inter-arrival times and the iterations
required to calculate a reaction. These assumptions are not clearly stated
in the paper, nor fairly compared with the standard hypothesis that the
"reaction time is always shorter than the minimum delay separating two
successive external events" (Rocheteau and Halbwachs, 1991) [OK?]. Calculating
an adequate Worst Case Reaction Time for a Céu program is surely more
subtle than for an Esterel or Lustre program with simultaneous external
events.

* The ordering of side-effects amounts to respecting the lexical ordering in
the program and possibly warning if program behavior may depend on this
ordering. This choice is not unreasonable and has, as the authors note,
been used in several other languages, but it limits the semantic
equivalences possible for subprograms and complicates manipulation and
optimization by compilers. I did not really understand how the analysis of
dangling pointers and memory leaks (§2.4) is supposed to work. Giving
function calls "intimidating names" is not a thorough solution: surely it
is possible to do better than that!

More sophisticated treatments of these ideas are attempted in the
"sequential constructiveness" of von Hanxleden et al in PDLI'14 [OK], and in
the "scheduling policies" of Caspi et al in LCTES'09 [OK].

> The treatment of first-class timers is unconvincing. It is trivial to let
> users write "await 10ms" in the text of a program, but how should such
> commands be implemented faithfully? What does "faithfully" even mean,
> exactly? The idea of resolving conflicts based on comparing parallel
> delays (as in the example of §2.5) seems superficial and strange to me.
>
> Such timer statements must inevitably be connected to implementation
> details (interrupts, execution periods, jitter, WCET, etc.), but how can
> this be done without losing the ideal of a mathematical and platform
> independent formal model? Bourke and Sowmya comment on some of these
> issues in SYNCHRON'09 [OK].

%%%
We included this reference in the paper and acknowledge their contributions.
In fact, our proposal is very close to theirs:
    - "program in terms of physical time"
    - "delay expressions should not unduly bias the mechanisms with which they
       are eventually realised"
    - "possible to program initially in ideal terms"

Their proposal transforms a <<delay time>> statement into appropriate Esterel
statements based on a hardware description given as a program declaration.
Our proposal makes physical time a special input event that feeds the runtime
with an associated time to count. Both proposals encompass sample and
interrupt-based timers.
We extend the related work (S.4) with this discussion.

About "faithful" fist-class timers, the scheduler of Céu runs reactions to
completion and possibly on top of some operating system.
For this reason, <<await time>> means awaiting *at least* <<time>>.
In the paper, we mention that the "interaction between system clocks and
programs is not absolutely precise".
We make this assumption more explicit in the paper.
That said, the runtime of Céu does not accumulate errors and is accurate about
timers in parallel:

    par/and do
        await 1us; await 1us; await 1us;
    with
        await 3us;
    end

The two trails always terminate together regardless of imprecise measurements
passed to the Céu runtime.
These conflicts are not resolved "based on comparing parallel delays", but as
consequence of "delta" compensation.
The example with timers in parallel illustrates that the abstract reasoning for
"1+1+1 == 3" always work in practice.
We rewrote the phrase that suggests that comparing parallel delays is a special
case.
%%%

> Other comments
> --------------

> §1
> - "Esterel has an overly complex semantics"
> 
> This is a subjective judgment. Esterel has a complex semantics compared
> with Lustre, for instance, but it is not more complex than necessary to
> treat its ambition of being a concurrent programming language with a basis
> in physics (casual circuits). How could the semantics be simplified
> without losing this intimate connection to an important class of digital
> circuits?

%%%
We removed "overly".
Although we maintain that Esterel is more complex than Céu, we agree that it
applies to other domains.
As commented above, we repositioned the paper as targeting soft real-time
systems.
%%%

> - "The complex semantics not only challenges the analysis and compilation of
> programs, but also results in incompatible and non-compliant
> implementations."
> 
> Where is the evidence for this assertion? If there is none, please remove it.

%%%
The cited references in the same paragraph discuss many approaches to deal with
the semantics of Esterel, but they do not necessarily generate "incompatible
and non-compliant implementations".
We rewrote this sentence as "A complex semantics not only challenges the
analysis and compilation of programs, but also affects the programmer's
understanding about the code, who, ultimately, has to solve the errors when
facing corner cases."
%%%

> §2.1

> - Esterel defines the behavior of a synchronous kernel, but it does not
> mandate how this kernel should be interfaced to the rest of the world. It
> would be possible, for instance, to implement an external queue and to
> feed events to an Esterel program one by one. These events would be
> declared exclusive, e.g, relation UL # UR # LL # LR, Esterel Primer 5.91,
> §4.4.4. The discussion in §2.1 should thus compare implementation schemes
> rather than languages.

%%%
We now discuss Esterel's input relations and comment that making all inputs
exclusive and adopting the "variable-length ticks" is equivalent to Céu's
"unique input" notion of time (i.e., Céu imposes a restriction on the semantics
of Esterel).
%%%

> - What you term "fixed-length ticks" is normally called "sample-driven
> execution" (see, e.g., Benveniste et al, Proc IEEE, fig. 1) [OK].

%%%
We now make this remark in the text.
We avoided the term because we have seen "adaptive/variable sample frequency/rate"
in other software contexts (e.g., games).
The term is also symmetric with "variable-length ticks" in our comparison.
%%%

> - "A "tick" is too abstract and imprecise. Outside the domain of hardware
> specification, a tick has no natural counterpart in the real world."
>
> Neither of these statements is true. Sample-driven execution is the
> simplest and most precise way of aligning program behavior to real time.
> Besides the (large and important) domain of hardware specification,
> sample-driven controllers are ubiquitous in control systems and embedded
> software. What could be more concrete and precise than regularly executing
> code on a microcontroller? There is a sort of non-determinism in whether
> an event will be sampled in tick i or in tick i+1, which can lead to
> problems detecting temporal orderings among events (see, e.g., Kopetz
> 1997, Chapter 3) [OK], but I do not see how this intrinsic problem is solved by
> the proposed execution scheme.

%%%
The suggested reference describes the concept of an "omniscient external
observer with an absolute reference clock that can generate precise timestamps
for all relevant events".
Since this concept applies to synchronous systems with zero-delay
communication, our paper uses the "Real World" box (S.2.1) as an absolute and
concrete time reference.
We consider that an Esterel tick is concrete only when its length is realized
into an implementation but not at the specification time.
If we log the absolute observation and execute it in Esterel implementations
with different tick lengths, the behaviors might diverge.
One can still use the tick length as meta information in the timeline, but
arguably this is in another level of abstraction.
The proposed scheme can fail to meet deadlines (S.2.1), but timestamped inputs
can be simulated at any speed in Céu with the same behavior
(we use this technique in automated tests for the language implementation).

We included this discussion in the paper and change the term "abstract" for
Esterel ticks (in favor of "implementation dependent").
%%%

> The choice made for CÉU seems reasonable. As for any other choice it comes
> with its own advantages and disadvantages. Why not just argue that this
> choice is suitable for the applications of interest? There is no need for
> a sort of pseudo-philosophical discussion, nor to argue that the choices
> made in the design of Esterel are bad.

%%%
Before justifying the choice for queue-based semantics, we counterpoint that
tick-based reactions are simpler and map directly to hardware implementations
(e.g., no runtime queues).
We now consider the soft real time application domain of Céu.
We also reduced the conceptual discussion.
%%%

> - "the two approaches for Esterel [...] lead to different behaviors for the
> same sequence of inputs".
> 
> The reality is a bit more subtle. Esterel programs are deterministic: they
> always give the same sequence of outputs for the same sequence of inputs.
> If the interface environment generates a different sequence of inputs,
> then it is reasonable for a program to generate a different sequence of
> outputs. There is, however, a real question about the observed ordering
> and time of events. But this is not properly formalized or resolved in
> your paper.

%%%
As commented above, the paper discusses an absolute timeline with events and
timestamps.
In this case, different tick lengths generate different sets of inputs.
%%%

> - "The synchronous hypothesis for CÉU holds if the reactions run faster than
> the rate of incoming input events."
> 
> Right, but it is not enough to consider the minimum arrival time between
> any two occurrences of the same event, but rather the average number of
> all events that can occur per unit of time. Furthermore, it is not enough
> to compare this value to the worst-case time to execute a single reaction,
> there is a more complicated interaction between the arrival of events and
> the time taken to process each of them.
>
> "This is also the case for the variable-length-tick approach of Esterel,
> since the more inputs to handle, the longer the reaction takes, and the
> more inputs accumulates for subsequent ticks."
> 
> It would be nice to see precise formulas for all three schemes
> (sample-driven, queue-driven, variable-length ticks). Little is learned
> from the informal discussion in the paper. The problem must be posed
> precisely before it can be analyzed.
> 
> Similar comments apply to the later statement (§2.6): "As a synchronous
> language, CÉU requires CPU times for reactions to be negligible in
> comparison to the rate of incoming events."

%%%
We haven't formalized the interaction of the language with the environment yet.
The formal semantics of Céu specifies a reaction to a single event [3] (i.e.,
the queue is external to the formal language, as illustrated in S.3.6).
In S.3.5, we mention previous work with the implementation of a radio driver
running in parallel with time-consuming tasks (e.g. computing hashes) [1].
We argue that "(hard real-time systems) requires careful testing to avoid
undersized hardware deployment without proper formalization".
As commented above, we repositioned the paper as targeting soft real-time
systems.
In S.2.6, we referenced S.3.5 and S.3.6 for the comments above.

TODO: extend 3.5?
TODO: merged 3.5/3.6?
%%%

> §2.2
> - A comparison can be made between the model of "Stack-Based Internal
> Events" and the ones of StateCharts (e.g., Harel and Naamad, 1996) [OK] and the
> MathWorks Stateflow tool [OK]. These models also try to treat events one by
> one, but not in exactly the same way.

%%%
In Statemate, "reactions to external and internal events (...) can be sensed only
after completion of the step", implying queue-based execution.
In Stateflow, "the receiving state (of the event) acts here as a function",
which is similar to Céu's stack-based execution.
These references are relevant and we included a comparison in S.4 (Related Work).
%%%

> - "same-cycle bi-directional communication" is also called an "instantaneous
> dialogue" (Halbwachs Book, 1993, §2.4.3) [OK].

%%%
We included this remark in the text and cited the reference.
%%%

> §2.3
> - It is worth noting that Esterel does impose restrictions on variable reads
> and writes in parallel components. Berry, v5.92 Primer, §3.5: "The rule is
> simple and classical: a variable is local to a thread in case the thread
> writes it. If the thread forks on a '||' parallel statement, then only two
> cases are legal: - The variable is accessed in read-only mode in each
> subthread, - If the variable is written by some thread, then it can
> neither be read nor be written by concurrent threads".

%%%
We now include this sentence in this paper (we used this very same sentence in
previous work).
%%%

> - I did not understand why this simple static check is called a "temporal
> analysis".

%%%
The term probably raises a different expectation to the reader, so we now use
"concurrency checks" instead of "temporal analysis".
As a justification for the term "analysis", the checks evolved from a
compile-time simulation with more precise results and also detection of
non-terminating statements, conflicting termination of "par/or", and some other
checks.
However, from our experience, the simple checks are efficient and good enough
in practice.
%%%

§2.4
- How does the compiler know that an "fopen" requires a later "fclose"?
Where is this expressed in the program or interface files?

-Why present the example in Figure 9 if it does not work properly? Is there
not a way to make this example work properly in CÉU?

-I was lost in this section. The informal descriptions and examples are
insufficient to understand how the scheme is supposed to work in general.

> §2.5
> - Is the description of the example correct? I would have expected the
> program to terminate with v = 2.

%%%
Yes, the description is correct:
  - The first trail awakes first (10+1 > 12) and terminates the <<par/or>>.
  - The second trail is aborted and never awakes.
We extended the text with this explanation.
%%%

- "which is a huge amount of time for a language-defined tick": this
statement is subjective and lacks precision. 200 milliseconds may not be
much time at all for some applications.

§2.6
- "Programmers can always figure out which statement executes next, making
runtime analysis and debugging easier." This claim is unsupported.
Programmers may have to reason over long chains of event sequences to
figure out what a given program does. It can be harder to state and reason
using invariants in such circumstances.

§3
- "Unfortunately, most real applications in Esterel seem to be closed
source."

Nevertheless, several examples are available:
- The Digital Watch, Berry 1991 and 2000 (source in appendix).
- Edward's estbench suite:
http://www1.cs.columbia.edu/~sedwards/software/estbench-1.0.tar.gz
- The test files of the CEC compiler:
https://github.com/LudvikGalois/cec-esterel/tree/master/tests
- The HDLC protocol, Berry & Gonthier 1989 (source in appendix).
- The examples that come with the KIELER tool:
http://git.rtsys.informatik.uni-kiel.de/projects/KIELER/repos/models/browse/esterel
(including a solution to the "Backhoe" programming exercise:
http://www.tbrk.org/esterel/backhoe.html)

%%%
Please, refer to the comments to Referee 1 above.
%%%

§3.1
- I would have preferred a formal presentation of the static analysis of
concurrent statements, i.e., deduction rules following the abstract syntax
of the language.

The rule for sequence nodes is unclear: isn't it possible to put awaits in
sequence, e.g., await A; await B; await C? How can I_n = O_n-1 in this
case?

I could not tell whether your pairing algorithm took advantage of the
hierarchical structure of nested parallel statements.

Could this algorithm be made modular? Or is it necessarily a "whole
program" analysis? I wonder how it would scale to large programs.

§3.3
- Do you "flatten" the hierarchical structure of a program to identify all
trails?
Or are you able to take advantage of the hierarchical structure of a
program to minimize the computation needed at each reaction?

yes!
o programa eh representado de maneira flat
    - so faz diferenca no CLEAR, mas ele carrega o range no codigo
      tb de maneira "flat"
- nao eh percorrido hierarquicamente
    - a trail can only be awaiting in one point
    - a gente sabe o num max do par
- desvantagem: pedacos inativos sao percorridos do mesmo jeito
    - regularity, WCET

Minor details
-------------

% OK
% lighter backgrounds, typos, text improvements, clarifications,
% full names in references

> §2.1
> - "Note that, by definition, each reaction corresponds to an event
> occurrence of the same length." What does this mean?

We removed this sentence.

§2.2
- "similarly to coroutines [Moura and" -> "similarly to coroutines
  [de Moura and" (?)

§2.6
- "Reactions must execute in bounded time due to the synchronous
hypothesis."

-> "The synchronous hypothesis requires that reactions execute in bounded
time."

References
- Please display names in the references in the format "Lastname, Firstname"
and sort them alphabetically by last name. Otherwise it is very tedious to
look them up from references in the text.


[1] Francisco Sant’Anna, Noemi Rodriguez, Roberto Ierusalimschy, Olaf
    Landsiedel, and Philippas Tsigas. 2013. Safe System-level Concurrency on
    Resource-Constrained Nodes. In Proceedings of SenSys’13. ACM.
[2] https://github.com/HandelSM/Ceu-arduino
[3] Francisco Sant’Anna. 2013. Safe System-level Concurrency on
    Resource-Constrained Nodes with Céu. Ph.D. Dissertation. PUC–Rio.
[4] Weil, Daniel, et al. "Efficient compilation of Esterel for real-time
    embedded systems." Proceedings of the 2000 international conference on
    Compilers, architecture, and synthesis for embedded systems. ACM, 2000.

--------------------------------------------------------------------------------

TODO: regarding
TODO: simplifies
