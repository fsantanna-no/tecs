-------------------------------------------------------------------------------

Referee: 1

Comments to the Author
1. The name of "static temporal analysis" may get confused with the existing
work on static timing analysis (e.g., WCET or WCRT) on synchronous language,
e.g., ''Performance Debugging of Esterel Specifications'' in RTS Journal, 2012
[OK]
Maybe it can be renamed as "static concurrency analysis".

%%%
To also address the comments of Referee 3, we renamed as "concurrency checks".
Please see below for additional comments.
%%%

2. Furthermore, lexical order is used to schedule the concurrent statements in
this work. What happens if there are data dependencies in the concurrent
statements? Please discuss the proposed scheduling with the existing
sequentialization techniques for Esterel compilation (e.g., a CFG-based
compilation) [OK?].

%%%
The idea of data dependency is inherent to Esterel since it supports emitting
and testing the presence of a signal in the same cycle.
Due to the "coherence law", Esterel also requires that an <<emit>> must precede
a <<present>> test.
Therefore, CFG-based compilers create an acyclic graph respecting topological
order to satisfy these constraints.

Section 2.2 discusses internal events and describes that if an <<await>> and
<<emit>> occur simultaneously in parallel trails, the <<await>> does not awake.
Delayed awaits eliminate the idea of data dependency in Céu but are less
expressive. We discuss the tradeoffs in the paper.
In Section 3.3, we mention a field in the trail structure to deal with delayed
awaits in the implementation.

In this revision, we extended Sections 2.2 and 4 (related work) to clarify
this discussion.
%%%

3. The authors mentioned that "Unfortunately, most real applications in Esterel
seems to be closed source". However, the Estbench (available at
http://www1.cs.columbia.edu/~sedwards/software.html) [OK] can be used to
perform the comparison and evaluation.

-------------------------------------------------------------------------------

Referee: 2

Comments to the Author
No further comments.

-------------------------------------------------------------------------------

Referee: 3

The subsections on Single-Threaded Dispatching (§3.5) and
the Terra Virtual Machine (§3.7) are uninformative.

On the whole, I would
have preferred a more neutral style (some parts of the paper read like a
sales pitch),

a fairer evaluation of Esterel (there are good reasons for its
design choices),

and a more formal description of the language and its
implementation (at the very least, a concise definition of the core abstract
syntax -- I just noticed that the original submission included this
definition in Figure 10; in my opinion, it was a mistake to remove it).

Ignoring superficial details (why must every language propose a new
syntax?), two interesting scientific questions underlie the work on Céu:

1. How to order side-effects within a synchronous reaction when interfacing
with realistic embedded systems?

2. How to program with real-time in certain embedded applications?

The problem is not simply to provide these as features but to do so without
losing the defining characteristics and advantages of synchronous languages.
Namely, an underlying mathematical model that is amenable to formal
manipulations and verification, and isolated 'enough' from low-level
implementation details while still permitting practical programming and
efficient implementations. These requirements are obviously difficult to
enunciate and subject to taste. The solutions embodied in Céu are well
motivated but involve trade-offs that could be more thoroughly discussed in
the paper. In particular,

* The queueing of external events and the stacking of internal ones
simplifies compilation and static analysis but complicates the formal
model and reasoning, which must account for a list of pending events, and
the relationship between reactions and real-time, as more complicated
assumptions are required on event inter-arrival times and the iterations
required to calculate a reaction. These assumptions are not clearly stated
in the paper, nor fairly compared with the standard hypothesis that the
"reaction time is always shorter than the minimum delay separating two
successive external events" (Rocheteau and Halbwachs, 1991) [OK?]. Calculating
an adequate Worst Case Reaction Time for a Céu program is surely more
subtle than for an Esterel or Lustre program with simultaneous external
events.

* The ordering of side-effects amounts to respecting the lexical ordering in
the program and possibly warning if program behavior may depend on this
ordering. This choice is not unreasonable and has, as the authors note,
been used in several other languages, but it limits the semantic
equivalences possible for subprograms and complicates manipulation and
optimization by compilers. I did not really understand how the analysis of
dangling pointers and memory leaks (§2.4) is supposed to work. Giving
function calls "intimidating names" is not a thorough solution: surely it
is possible to do better than that!

More sophisticated treatments of these ideas are attempted in the
"sequential constructiveness" of von Hanxleden et al in PDLI'14 [OK], and in
the "scheduling policies" of Caspi et al in LCTES'09 [OK].

* The treatment of first-class timers is unconvincing. It is trivial to let
users write "await 10ms" in the text of a program, but how should such
commands be implemented faithfully? What does "faithfully" even mean,
exactly? The idea of resolving conflicts based on comparing parallel
delays (as in the example of §2.5) seems superficial and strange to me.

Such timer statements must inevitably be connected to implementation
details (interrupts, execution periods, jitter, WCET, etc.), but how can
this be done without losing the ideal of a mathematical and platform
independent formal model? Bourke and Sowmya comment on some of these
issues in SYNCHRON'09 [OK].

I hope that the authors will pursue these fundamental issues with a more
critical approach in their future work.

Other comments
--------------
§1
- "Esterel has an overly complex semantics"

This is a subjective judgment. Esterel has a complex semantics compared
with Lustre, for instance, but it is not more complex than necessary to
treat its ambition of being a concurrent programming language with a basis
in physics (casual circuits). How could the semantics be simplified
without losing this intimate connection to an important class of digital
circuits?

- "The complex semantics not only challenges the analysis and compilation of
programs, but also results in incompatible and non-compliant
implementations."

Where is the evidence for this assertion? If there is none, please remove it.

§2.1
- Esterel defines the behavior of a synchronous kernel, but it does not
mandate how this kernel should be interfaced to the rest of the world. It
would be possible, for instance, to implement an external queue and to
feed events to an Esterel program one by one. These events would be
declared exclusive, e.g, relation UL # UR # LL # LR, Esterel Primer 5.91,
§4.4.4. The discussion in §2.1 should thus compare implementation schemes
rather than languages.

- What you term "fixed-length ticks" is normally called "sample-driven
execution" (see, e.g., Benveniste et al, Proc IEEE, fig. 1) [OK].

- "A "tick" is too abstract and imprecise. Outside the domain of hardware
specification, a tick has no natural counterpart in the real world."

Neither of these statements is true. Sample-driven execution is the
simplest and most precise way of aligning program behavior to real time.
Besides the (large and important) domain of hardware specification,
sample-driven controllers are ubiquitous in control systems and embedded
software. What could be more concrete and precise than regularly executing
code on a microcontroller? There is a sort of non-determinism in whether
an event will be sampled in tick i or in tick i+1, which can lead to
problems detecting temporal orderings among events (see, e.g., Kopetz
1997, Chapter 3) [OK], but I do not see how this intrinsic problem is solved by
the proposed execution scheme.

The choice made for CÉU seems reasonable. As for any other choice it comes
with its own advantages and disadvantages. Why not just argue that this
choice is suitable for the applications of interest? There is no need for
a sort of pseudo-philosophical discussion, nor to argue that the choices
made in the design of Esterel are bad.

- "the two approaches for Esterel [...] lead to different behaviors for the
same sequence of inputs".

The reality is a bit more subtle. Esterel programs are deterministic: they
always give the same sequence of outputs for the same sequence of inputs.
If the interface environment generates a different sequence of inputs,
then it is reasonable for a program to generate a different sequence of
outputs. There is, however, a real question about the observed ordering
and time of events. But this is not properly formalized or resolved in
your paper.

- "The synchronous hypothesis for CÉU holds if the reactions run faster than
the rate of incoming input events."

Right, but it is not enough to consider the minimum arrival time between
any two occurrences of the same event, but rather the average number of
all events that can occur per unit of time. Furthermore, it is not enough
to compare this value to the worst-case time to execute a single reaction,
there is a more complicated interaction between the arrival of events and
the time taken to process each of them.

"This is also the case for the variable-length-tick approach of Esterel,
since the more inputs to handle, the longer the reaction takes, and the
more inputs accumulates for subsequent ticks."

It would be nice to see precise formulas for all three schemes
(sample-driven, queue-driven, variable-length ticks). Little is learned
from the informal discussion in the paper. The problem must be posed
precisely before it can be analyzed.

Similar comments apply to the later statement (§2.6): "As a synchronous
language, CÉU requires CPU times for reactions to be negligible in
comparison to the rate of incoming events."

§2.2
- A comparison can be made between the model of "Stack-Based Internal
Events" and the ones of StateCharts (e.g., Harel and Naamad, 1996) [OK] and the
MathWorks Stateflow tool [OK]. These models also try to treat events one by
one, but not in exactly the same way.

- "same-cycle bi-directional communication" is also called an "instantaneous
dialogue" (Halbwachs Book, 1993, §2.4.3) [OK].

§2.3
- It is worth noting that Esterel does impose restrictions on variable reads
and writes in parallel components. Berry, v5.92 Primer, §3.5: "The rule is
simple and classical: a variable is local to a thread in case the thread
writes it. If the thread forks on a '||' parallel statement, then only two
cases are legal: - The variable is accessed in read-only mode in each
subthread, - If the variable is written by some thread, then it can
neither be read nor be written by concurrent threads".

- I did not understand why this simple static check is called a "temporal
analysis".

%%%
We acknowledge that the term possibly raises a different expectation to the
reader, so we now use "concurrency checks" instead of "temporal analysis".
As a justification for the term "analysis", the checks evolved from a
compile-time simulation for more precise results and detection of
non-terminating statements, conflicting termination of "par/or", and some other
checks (unrelated to the paper).
However, from our experience, the simple checks are efficient and good enough
in practice.
%%%

§2.4
- How does the compiler know that an "fopen" requires a later "fclose"?
Where is this expressed in the program or interface files?

-Why present the example in Figure 9 if it does not work properly? Is there
not a way to make this example work properly in CÉU?

-I was lost in this section. The informal descriptions and examples are
insufficient to understand how the scheme is supposed to work in general.

§2.5
- Is the description of the example correct? I would have expected the
program to terminate with v = 2.

- "which is a huge amount of time for a language-defined tick": this
statement is subjective and lacks precision. 200 milliseconds may not be
much time at all for some applications.

§2.6
- "Programmers can always figure out which statement executes next, making
runtime analysis and debugging easier." This claim is unsupported.
Programmers may have to reason over long chains of event sequences to
figure out what a given program does. It can be harder to state and reason
using invariants in such circumstances.

§3
- "Unfortunately, most real applications in Esterel seem to be closed
source."

Nevertheless, several examples are available:
- The Digital Watch, Berry 1991 and 2000 (source in appendix).
- Edward's estbench suite:
http://www1.cs.columbia.edu/~sedwards/software/estbench-1.0.tar.gz
- The test files of the CEC compiler:
https://github.com/LudvikGalois/cec-esterel/tree/master/tests
- The HDLC protocol, Berry & Gonthier 1989 (source in appendix).
- The examples that come with the KIELER tool:
http://git.rtsys.informatik.uni-kiel.de/projects/KIELER/repos/models/browse/esterel
(including a solution to the "Backhoe" programming exercise:
http://www.tbrk.org/esterel/backhoe.html)

§3.1
- I would have preferred a formal presentation of the static analysis of
concurrent statements, i.e., deduction rules following the abstract syntax
of the language.

The rule for sequence nodes is unclear: isn't it possible to put awaits in
sequence, e.g., await A; await B; await C? How can I_n = O_n-1 in this
case?

I could not tell whether your pairing algorithm took advantage of the
hierarchical structure of nested parallel statements.

Could this algorithm be made modular? Or is it necessarily a "whole
program" analysis? I wonder how it would scale to large programs.

§3.3
- Do you "flatten" the hierarchical structure of a program to identify all
trails?
Or are you able to take advantage of the hierarchical structure of a
program to minimize the computation needed at each reaction?

yes!
o programa eh representado de maneira flat
    - so faz diferenca no CLEAR, mas ele carrega o range no codigo
      tb de maneira "flat"
- nao eh percorrido hierarquicamente
    - a trail can only be awaiting in one point
    - a gente sabe o num max do par
- desvantagem: pedacos inativos sao percorridos do mesmo jeito
    - regularity, WCET

Minor details
-------------

% OK
% lighter backgrounds, typos, text improvements, clarifications,
% full names in references

§2.1
- "Note that, by definition, each reaction corresponds to an event
occurrence of the same length." What does this mean?

§2.2
- "similarly to coroutines [Moura and" -> "similarly to coroutines
  [de Moura and" (?)

§2.6
- "Reactions must execute in bounded time due to the synchronous
hypothesis."

-> "The synchronous hypothesis requires that reactions execute in bounded
time."

References
- Please display names in the references in the format "Lastname, Firstname"
and sort them alphabetically by last name. Otherwise it is very tedious to
look them up from references in the text.
