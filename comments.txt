-------------------------------------------------------------------------------

> Referee: 1

> 1. The name of "static temporal analysis" may get confused with the existing
> work on static timing analysis (e.g., WCET or WCRT) on synchronous language,
> e.g., ''Performance Debugging of Esterel Specifications'' in RTS Journal, 2012
> Maybe it can be renamed as "static concurrency analysis".

To also address the comments of "Referee 3", we renamed the term as
"concurrency checks".

> 2. Furthermore, lexical order is used to schedule the concurrent statements
> in this work. What happens if there are data dependencies in the concurrent
> statements? Please discuss the proposed scheduling with the existing
> sequentialization techniques for Esterel compilation (e.g., a CFG-based
> compilation).

The idea of data dependency is inherent to Esterel since it supports emitting
and testing the presence of a signal in the same cycle.
Due to the "coherence law", Esterel also requires that an <<emit>> must precede
a <<present>> test.
CFG-based compilers create acyclic graphs respecting topological in order to
satisfy these constraints.

S.2.2 (Stack-Based Internal Events) discusses internal events and describes
that if an <<await>> and <<emit>> occur simultaneously in parallel trails, the
<<await>> does not awake.
Delayed awaits eliminate the idea of data dependency in Céu but are less
expressive. We discuss the tradeoffs in this section.
In S.3.3 (Static and Lightweight Trail Allocation), we mention a field in the
trail structure to deal with delayed awaits in the implementation.

We extended S.2.2 and S.4 (Related Work) to include this discussion.

> 3. The authors mentioned that "Unfortunately, most real applications in
> Esterel seems to be closed source". However, the Estbench (available at
> http://www1.cs.columbia.edu/~sedwards/software.html) can be used to
> perform the comparison and evaluation.

Maybe "widely-used applications" would be a more accurate term to use.
The TinyOS drivers and protocols (which we ported to Céu) are industrial-level
applications and serve as basis for a considerable amount of work in the
Wireless Sensor Network academic community (e.g., ACM SenSys, ACM IPSN,
IEEE DCOSS, and EWSN).
Although we avoid any quantitative comparisons with Esterel, the cited work [1]
is about a comprehensive evaluation in a constrained and distributed setting
showing a small overhead in resource usage in comparison to C.
We recognize that a quantitative analysis with Esterel is relevant, but C is
a standard benchmark language for evaluating embedded systems.
An Esterel implementation that compiles to sequential C code with similar
techniques "generates code less than 10% larger the original manually-sequenced
code" [4].
We plan to extend our evaluation with industrial-quality applications in future
work.

We rewrote the 2nd paragraph of S.3 (Implementation) with the justification
above and moved this discussion to S.3.5 (Single-Threaded Dispatching).

-------------------------------------------------------------------------------

> Referee: 3

> The subsections on Single-Threaded Dispatching (§3.5) and
> the Terra Virtual Machine (§3.7) are uninformative.

TODO:

> On the whole, I would have preferred a more neutral style (some parts of the
> paper read like a sales pitch)...
> ... a fairer evaluation of Esterel (there are good reasons for its design
> choices), ...
> ... The solutions embodied in Céu are well motivated but involve trade-offs
> that could be more thoroughly discussed in the paper.

We re-positioned Céu as targeting soft real-time systems only.
This changes the tone of the paper as less ambitious in comparison to Esterel
for a fairer evaluation.
We rewrote parts of the Abstract, S.1 (Introduction), S.3.5 (Single-Threaded
Dispatching), and S.5 (Conclusion), e.g.:

"The semantics of Céu implies an implementation with a runtime stack and a
sequential scheduler.
In contrast with Esterel's semantics, this prevents programs to be compiled
directly and efficiently to hardware [ref].
It also makes difficult to statically determine worst-case reaction times
for hard real-time systems [ref]."

"For soft real-time systems, accumulating delays and occasionally postponing
reactions might be enough.
However, hard real-time systems require a more robust approach such as
determining fixed-length ticks that can be statically verified."

"We present the design and implementation of Céu, ...
On the one hand, this approach ...
On the other hand, this level of abstraction does not suit systems with
hard-real time requirements, in which interacting directly with a concrete
notion of tick is more robust."

We also proof-read the paper and removed/renamed many non-neutral terms, e.g.:
"overly complex semantics", "imposed", "drawback", "loose execution",
"all-inclusive" "simple semantics", "only possible", "seamless",
"easily trackable", "goes one step further", "unique", and so on.

> ... a more formal description of the language and its
> implementation (at the very least, a concise definition of the core abstract
> syntax -- I just noticed that the original submission included this
> definition in Figure 10; ...).

We now present the subset of the concrete syntax of Céu used in the paper as a
quick reference (S.2, The Design of Céu, Figure 2).
We also point to "the formal specification of the semantics of Céu with a
simplified abstract syntax in a separate paper [ref]".

> * The queueing of external events and the stacking of internal ones
> simplifies compilation and static analysis but complicates the formal
> model and reasoning, ... These assumptions are not clearly stated
> in the paper, nor fairly compared with the standard hypothesis that the
> "reaction time is always shorter than the minimum delay separating two
> successive external events" (Rocheteau and Halbwachs, 1991). Calculating
> an adequate Worst Case Reaction Time for a Céu program is surely more
> subtle than for an Esterel or Lustre program with simultaneous external
> events.

In S.2.1 (Unique and Queue-Based External Events), we state that when the
synchronous hypothesis does not hold in Céu, "the application continuously
accumulates delays between the real occurrence and actual reaction of a given
event".
We now reposition Céu as soft real time and acknowledge that determining
worst-case reaction times is non trivial with our semantics.

> * The ordering of side-effects amounts to respecting the lexical ordering in
> the program and possibly warning if program behavior may depend on this
> ordering. This choice is not unreasonable and has, as the authors note,
> been used in several other languages, but it limits the semantic
> equivalences possible for subprograms and complicates manipulation and
> optimization by compilers.
> ...
> More sophisticated treatments of these ideas are attempted in the
> "sequential constructiveness" of von Hanxleden et al in PDLI'14, and in
> the "scheduling policies" of Caspi et al in LCTES'09.

We extended S.4 (Related Work) citing SCCharts since it is closer to our
approach:
"SCCharts [ref] proposes sequentially constructive programs that allow ``shared
variables to have multiple values per tick as long as these values are
explicitly ordered by sequential statements'' [ref].
This relaxes Esterel's restriction for read-after-write accesses only (e.g., a
signal must be emitted to be present) and permits write-after-read accesses
typical in imperative programs (e.g., test and set).
Although this approach still restricts concurrent accesses, it does not impose
strict deterministic scheduling such as in Céu."

> I did not really understand how the analysis of dangling pointers and memory
> leaks (§2.4) is supposed to work. Giving function calls "intimidating names"
> is not a thorough solution: surely it is possible to do better than that!

The discussion about dangling pointers and memory leaks (S.2.4.3, Finalization)
is not related to the <<@safe>> annotation and names (S.2.4.2, Annotations).
The proposed solution is to require the programmer to annotate the function as
<<@safe>>. The annotation tells the compiler to allow this function to be
called concurrently and rely on lexical order. Choosing an "intimidating name"
is not a mechanism, but a hint to improve readability and be explicit about
the effect of that call. We rewrote this paragraph.
We also rewrote parts of S.2.4.3 (Finalization) as discussed below.

> The treatment of first-class timers is unconvincing. It is trivial to let
> users write "await 10ms" in the text of a program, but how should such
> commands be implemented faithfully? What does "faithfully" even mean,
> exactly? The idea of resolving conflicts based on comparing parallel
> delays (as in the example of §2.5) seems superficial and strange to me.
>
> Such timer statements must inevitably be connected to implementation
> details (interrupts, execution periods, jitter, WCET, etc.), but how can
> this be done without losing the ideal of a mathematical and platform
> independent formal model? Bourke and Sowmya comment on some of these
> issues in SYNCHRON'09.

We included this reference in the paper and acknowledge their contributions.
In fact, our proposal is very close to theirs:
    - "program in terms of physical time"
    - "delay expressions should not unduly bias the mechanisms with which they
       are eventually realised"
    - "possible to program initially in ideal terms"

Their proposal transforms a <<delay time>> statement into appropriate Esterel
statements based on a hardware description given as a program declaration.
Our proposal makes physical time a special input event that feeds the runtime
with an associated time to count. Both proposals encompass sample and
interrupt-based timers.
We extend S.4 (Related Work) with this discussion.

About "faithful" fist-class timers, the scheduler of Céu runs reactions to
completion and possibly on top of some operating system.
For this reason, <<await time>> means awaiting *at least* <<time>>.
In the paper, we mention that the "interaction between system clocks and
programs is not absolutely precise".
We make this assumption more explicit in the paper.
That said, the runtime of Céu does not accumulate errors and is accurate about
timers in parallel:

    par/and do
        await 1us; await 1us; await 1us;
    with
        await 3us;
    end

The two trails always terminate together regardless of imprecise measurements
passed to the Céu runtime.
These conflicts are not resolved "based on comparing parallel delays", but as
consequence of "delta compensation".
The example with timers in parallel illustrates that the abstract reasoning for
"1+1+1 == 3" always work in practice.
We rewrote the phrase that suggests that comparing parallel delays is a special
case.

> Other comments
> --------------

> §1
> - "Esterel has an overly complex semantics"
> 
> This is a subjective judgment. Esterel has a complex semantics compared
> with Lustre, for instance, but it is not more complex than necessary to
> treat its ambition of being a concurrent programming language with a basis
> in physics (casual circuits). How could the semantics be simplified
> without losing this intimate connection to an important class of digital
> circuits?

We removed the term "overly".
Although we maintain that Esterel is more complex than Céu, we agree that it
applies to more domains.
As commented above, we repositioned the paper as targeting soft real-time
systems.

> - "The complex semantics not only challenges the analysis and compilation of
> programs, but also results in incompatible and non-compliant
> implementations."
> 
> Where is the evidence for this assertion? If there is none, please remove it.

The cited references in the same paragraph discuss many approaches to deal with
the semantics of Esterel, but we agree that they do not necessarily generate
"incompatible and non-compliant implementations".
We rewrote this sentence as "A complex semantics not only challenges the
analysis and compilation of programs, but also affects the programmer's
understanding about the code, who, ultimately, has to solve the errors when
facing corner cases" (removed the assertion and joined with the phrase in
sequence).

> §2.1

> - Esterel defines the behavior of a synchronous kernel, but it does not
> mandate how this kernel should be interfaced to the rest of the world. It
> would be possible, for instance, to implement an external queue and to
> feed events to an Esterel program one by one. These events would be
> declared exclusive, e.g, relation UL # UR # LL # LR, Esterel Primer 5.91,
> §4.4.4. The discussion in §2.1 should thus compare implementation schemes
> rather than languages.

We now discuss these Esterel's input relations and comment that making all
inputs exclusive and adopting the "variable-length ticks" is equivalent to
Céu's "unique input" notion of time (i.e., Céu imposes a restriction on the
semantics of Esterel).

> - What you term "fixed-length ticks" is normally called "sample-driven
> execution" (see, e.g., Benveniste et al, Proc IEEE, fig. 1).

We now make this remark in the text.
We avoided the term because we have seen "adaptive/variable sample frequency/rate"
in other software contexts (e.g., games).
The term is also symmetric with "variable-length ticks" in our comparison.

> - "A "tick" is too abstract and imprecise. Outside the domain of hardware
> specification, a tick has no natural counterpart in the real world."
>
> Neither of these statements is true. Sample-driven execution is the
> simplest and most precise way of aligning program behavior to real time.
> Besides the (large and important) domain of hardware specification,
> sample-driven controllers are ubiquitous in control systems and embedded
> software. What could be more concrete and precise than regularly executing
> code on a microcontroller? There is a sort of non-determinism in whether
> an event will be sampled in tick i or in tick i+1, which can lead to
> problems detecting temporal orderings among events (see, e.g., Kopetz
> 1997, Chapter 3), but I do not see how this intrinsic problem is solved by
> the proposed execution scheme.

The suggested reference describes the concept of an "omniscient external
observer with an absolute reference clock that can generate precise timestamps
for all relevant events".
Since this concept applies to synchronous systems with zero-delay
communication, our paper uses the "Real World" box (S.2.1, Unique and
Queue-Based External Events) as an absolute and concrete time reference.
We consider that an Esterel tick is concrete only when its length is realized
into an implementation, but not at the specification time.
If we log the absolute observation and execute it in Esterel implementations
with different tick lengths, the behaviors might diverge.
One can still use the tick length as meta information in the timeline, but
arguably this is in another level of abstraction.
The proposed scheme can fail to meet deadlines (S.2.1), but timestamped inputs
can be simulated at any speed in Céu with the same behavior
(we use this technique in automated tests for the language implementation).

We included this discussion in the paper and changed the term "abstract" for
Esterel ticks (in favor of "implementation dependent ticks").

> The choice made for CÉU seems reasonable. As for any other choice it comes
> with its own advantages and disadvantages. Why not just argue that this
> choice is suitable for the applications of interest? There is no need for
> a sort of pseudo-philosophical discussion, nor to argue that the choices
> made in the design of Esterel are bad.

Before justifying the choice for queue-based semantics, we counterpoint that
tick-based reactions are simpler and map directly to hardware implementations
(e.g., no runtime queues).
We now take into account the soft real-time application domain of Céu.
We also reduced the conceptual discussion.

> - "the two approaches for Esterel [...] lead to different behaviors for the
> same sequence of inputs".
> 
> The reality is a bit more subtle. Esterel programs are deterministic: they
> always give the same sequence of outputs for the same sequence of inputs.
> If the interface environment generates a different sequence of inputs,
> then it is reasonable for a program to generate a different sequence of
> outputs. There is, however, a real question about the observed ordering
> and time of events. But this is not properly formalized or resolved in
> your paper.

As commented above, the paper discusses an absolute timeline with events and
timestamps.
In this case, different tick lengths generate different sets of inputs.

> - "The synchronous hypothesis for CÉU holds if the reactions run faster than
> the rate of incoming input events."
> 
> Right, but it is not enough to consider the minimum arrival time between
> any two occurrences of the same event, but rather the average number of
> all events that can occur per unit of time. Furthermore, it is not enough
> to compare this value to the worst-case time to execute a single reaction,
> there is a more complicated interaction between the arrival of events and
> the time taken to process each of them.
>
> "This is also the case for the variable-length-tick approach of Esterel,
> since the more inputs to handle, the longer the reaction takes, and the
> more inputs accumulates for subsequent ticks."
> 
> It would be nice to see precise formulas for all three schemes
> (sample-driven, queue-driven, variable-length ticks). Little is learned
> from the informal discussion in the paper. The problem must be posed
> precisely before it can be analyzed.
> 
> Similar comments apply to the later statement (§2.6): "As a synchronous
> language, CÉU requires CPU times for reactions to be negligible in
> comparison to the rate of incoming events."

We haven't formalized the interaction of the language with the environment yet.
The formal semantics of Céu specifies a reaction to a single event [2] (i.e.,
the queue is external to the formal language, as illustrated in S.3.6
(Interaction with the Environment)).
In S.3.5 (Single-Threaded Dispatching), we mention previous work with the
implementation of a radio driver running in parallel with time-consuming tasks
(e.g. computing hashes) [1].
We argue that "(hard real-time systems) requires careful testing to avoid
undersized hardware deployment without proper formalization".
As commented above, we repositioned the paper as targeting soft real-time
systems.
In S.2.6 (Summary), we referenced S.3.5 and S.3.6 with the comments above.

> §2.2
> - A comparison can be made between the model of "Stack-Based Internal
> Events" and the ones of StateCharts (e.g., Harel and Naamad, 1996) and the
> MathWorks Stateflow tool. These models also try to treat events one by
> one, but not in exactly the same way.

In Statemate, "reactions to external and internal events (...) can be sensed
only after completion of the step", implying queue-based execution.
In Stateflow, "the receiving state (of the event) acts here as a function",
which is similar to Céu's stack-based execution.
These references are relevant and we included a comparison in S.4 (Related
Work).

> - "same-cycle bi-directional communication" is also called an "instantaneous
> dialogue" (Halbwachs Book, 1993, §2.4.3).

We included this remark in the text and cited the reference.

> §2.3
> - It is worth noting that Esterel does impose restrictions on variable reads
> and writes in parallel components. Berry, v5.92 Primer, §3.5: "The rule is
> simple and classical: a variable is local to a thread in case the thread
> writes it. If the thread forks on a '||' parallel statement, then only two
> cases are legal: - The variable is accessed in read-only mode in each
> subthread, - If the variable is written by some thread, then it can
> neither be read nor be written by concurrent threads".

We now include this sentence in this paper (we have already used this very same
sentence in previous work).

> - I did not understand why this simple static check is called a "temporal
> analysis".

The term probably raises a different expectation to the reader, so we now use
"concurrency checks" instead of "temporal analysis".
As a justification for the term "analysis", the checks evolved from a
compile-time simulation with more precise results and also detection of
non-terminating statements, conflicting termination of "par/or", etc.
However, from our experience, the simple checks are efficient and good enough
in practice.

> §2.4
> - How does the compiler know that an "fopen" requires a later "fclose"?
> Where is this expressed in the program or interface files?
>
> -Why present the example in Figure 9 if it does not work properly? Is there
> not a way to make this example work properly in CÉU?
>
> -I was lost in this section. The informal descriptions and examples are
> insufficient to understand how the scheme is supposed to work in general.

We propose an integration with existing C APIs and enforce safe behavior
without pre-existing work on interface files.
In the case of <<fopen>>/<<fclose>>, what we would do in practice is to handle
the system calls and finalization inside an abstraction [3] and expose that as
a library for programming with files in pure Céu.
In the case of <<lock>> in Figure 9, we could make the compiler complain
about any non-annotated function.
We rewrote this subsection more precisely and removed the <<lock>> example to
avoid confusion.
We also included a note that "The compiler only enforces the programmer to
write the finalization clause, but cannot check if it actually handles the
resource properly."

TODO: more precisely

> §2.5
> - Is the description of the example correct? I would have expected the
> program to terminate with v = 2.

Yes, the description is correct:
  - The first trail awakes first (10+1 > 12) and terminates the <<par/or>>.
  - The second trail is aborted and never awakes.
We extended the text with this explanation.

> - "which is a huge amount of time for a language-defined tick": this
> statement is subjective and lacks precision. 200 milliseconds may not be
> much time at all for some applications.

Ok, but many applications require much smaller sampling ticks.
We rewrote the sentence.

> §2.6
> - "Programmers can always figure out which statement executes next, making
> runtime analysis and debugging easier." This claim is unsupported.
> Programmers may have to reason over long chains of event sequences to
> figure out what a given program does. It can be harder to state and reason
> using invariants in such circumstances.

Stack execution and lexical order are deterministic and familiar to
programmers. We rewrote as "Programmers can figure out which statement executes
next, helping runtime analysis and debugging".

> §3
> - "Unfortunately, most real applications in Esterel seem to be closed
> source."
>
> Nevertheless, several examples are available:
> - The Digital Watch, Berry 1991 and 2000 (source in appendix).
> - Edward's estbench suite:
> ...

Please, refer to the comments for "Referee 1" at the top of the file.

> §3.1
> - I would have preferred a formal presentation of the static analysis of
> concurrent statements, i.e., deduction rules following the abstract syntax
> of the language.

We removed the formal runtime semantics after the first review.
We plan to describe it in future work and extend it with the static semantics
as well.

> The rule for sequence nodes is unclear: isn't it possible to put awaits in
> sequence, e.g., await A; await B; await C? How can I_n = O_n-1 in this
> case?

In this case, the sequence node has three children:
    1: <<await A>> has I={boot}
                       O={A}
    2: <<await B>> has I={A} (O of the preceding node 1)
                       O={B}
    3: <<await C>> has I={B} (O of the preceding node 2)
                       O={C}

> I could not tell whether your pairing algorithm took advantage of the
> hierarchical structure of nested parallel statements.
>
> Could this algorithm be made modular? Or is it necessarily a "whole
> program" analysis? I wonder how it would scale to large programs.

Once we compare nested parallel statements, we can reduce them to the union
of all side-effect nodes (i.e., the symbol, operation, and reaching inputs).
Removing the hierarchy saves space but preserves the quadratic behavior.
We did not evaluate the performance of the concurrency checks though.

> §3.3
> - Do you "flatten" the hierarchical structure of a program to identify all
> trails?
> Or are you able to take advantage of the hierarchical structure of a
> program to minimize the computation needed at each reaction?

Yes, the language runtime is flat and has no hierarchy information.
All trails, active or inactive, are traversed in all reactions.
We believe that this makes worst-case reaction times lower (i.e., if all trails
are active, traversing a hierarchy would make a reaction even slower).
It also makes all reaction times to be more predictable.
However, we did not investigate these assumptions.
We included this analysis in the paper.

> Minor details
> -------------
> ...

As suggested, we made the listing background lighter, corrected many typos,
removed some sentences, made text improvements and clarifications, and fixed
the references.

-------------------------------------------------------------------------------

[1] Francisco Sant’Anna, Noemi Rodriguez, Roberto Ierusalimschy, Olaf
    Landsiedel, and Philippas Tsigas. 2013. Safe System-level Concurrency on
    Resource-Constrained Nodes. In Proceedings of SenSys’13. ACM.
[2] Francisco Sant’Anna. 2013. Safe System-level Concurrency on
    Resource-Constrained Nodes with Céu. Ph.D. Dissertation. PUC–Rio.
[3] Francisco Sant’Anna, Noemi Rodriguez, and Roberto Ierusalimschy. 2015.
    Structured Synchronous Reactive Programming with Céu. In Proceedings of
    Modularity’15
[4] Weil, Daniel, et al. "Efficient compilation of Esterel for real-time
    embedded systems." Proceedings of the 2000 international conference on
    Compilers, architecture, and synthesis for embedded systems. ACM, 2000.
